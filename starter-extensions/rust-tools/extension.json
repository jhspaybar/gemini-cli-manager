{
  "id": "rust-tools",
  "name": "Rust Development Tools",
  "version": "1.0.0",
  "description": "Comprehensive Rust development support with cargo integration, rust-analyzer, and best practices guidance",
  "mcp_servers": {
    "rust-analyzer": {
      "command": "rust-analyzer",
      "args": ["--stdio"],
      "cwd": ".",
      "timeout": 30000
    },
    "cargo-tools": {
      "command": "cargo",
      "args": ["run", "--bin", "mcp-server"],
      "cwd": ".",
      "env": {
        "RUST_LOG": "info"
      }
    }
  },
  "context_file_name": "GEMINI.md",
  "context_content": "# GEMINI.md - Rust Development Guide\n\nThis comprehensive guide provides patterns, best practices, and conventions for Rust development. It is designed to help you write safe, performant, and idiomatic Rust code.\n\n## Table of Contents\n1. [Cargo Best Practices](#cargo-best-practices)\n2. [Error Handling](#error-handling)\n3. [Memory Management](#memory-management)\n4. [Async Programming](#async-programming)\n5. [Testing Strategy](#testing-strategy)\n6. [Performance Guidelines](#performance-guidelines)\n7. [Security Considerations](#security-considerations)\n8. [Common Patterns](#common-patterns)\n9. [Development Workflow](#development-workflow)\n10. [Debugging Tips](#debugging-tips)\n\n## Cargo Best Practices\n\n### Essential Cargo Commands\n\n```bash\n# Create a new project\ncargo new my_project --bin  # Binary project\ncargo new my_lib --lib      # Library project\n\n# Build with optimizations\ncargo build --release\n\n# Run with optimizations\ncargo run --release\n\n# Check code without building\ncargo check\n\n# Run tests\ncargo test\ncargo test -- --nocapture  # Show println! output\n\n# Generate and open documentation\ncargo doc --open\n\n# Update dependencies\ncargo update\n\n# Audit dependencies for security vulnerabilities\ncargo audit\n```\n\n### Cargo.toml Configuration\n\n```toml\n[package]\nname = \"my_project\"\nversion = \"0.1.0\"\nedition = \"2021\"  # Always use the latest edition\n\n[dependencies]\n# Specify exact versions for reproducible builds\nserde = { version = \"1.0.193\", features = [\"derive\"] }\ntokio = { version = \"1.35.0\", features = [\"full\"] }\n\n[dev-dependencies]\n# Development-only dependencies\npretty_assertions = \"1.4.0\"\ncriterion = \"0.5.1\"\n\n[profile.release]\n# Optimize for size\nopt-level = \"z\"\nlto = true\ncodegen-units = 1\nstrip = true\n\n[profile.dev]\n# Faster compilation for development\nopt-level = 0\ndebug = true\n```\n\n### Make Warnings Errors\n\n**Always treat warnings as errors in CI/production:**\n\n```rust\n// In lib.rs or main.rs\n#![deny(warnings)]\n#![deny(clippy::all)]\n#![deny(clippy::pedantic)]\n#![deny(clippy::nursery)]\n#![deny(missing_docs)]\n#![deny(missing_debug_implementations)]\n```\n\nOr in Cargo.toml:\n\n```toml\n[lints.rust]\nwarnings = \"deny\"\nunsafe_code = \"deny\"\nmissing_docs = \"deny\"\n\n[lints.clippy]\nall = \"deny\"\npedantic = \"deny\"\nnursery = \"deny\"\n```\n\n### Dependency Management\n\n```bash\n# Add dependencies properly\ncargo add serde --features derive\ncargo add tokio --features full\ncargo add --dev pretty_assertions\n\n# Check for outdated dependencies\ncargo install cargo-outdated\ncargo outdated\n\n# Check for security vulnerabilities\ncargo install cargo-audit\ncargo audit\n\n# Minimize dependencies\ncargo tree  # View dependency tree\ncargo tree --duplicates  # Find duplicate dependencies\n```\n\n## Error Handling\n\n### Use Result<T, E> Everywhere\n\n```rust\nuse thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum AppError {\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n    \n    #[error(\"Parse error: {0}\")]\n    Parse(#[from] std::num::ParseIntError),\n    \n    #[error(\"Custom error: {message}\")]\n    Custom { message: String },\n}\n\n// Always return Result\npub fn risky_operation() -> Result<String, AppError> {\n    let data = std::fs::read_to_string(\"config.toml\")?;\n    let value: i32 = data.parse()?;\n    \n    if value < 0 {\n        return Err(AppError::Custom {\n            message: \"Value must be positive\".to_string(),\n        });\n    }\n    \n    Ok(format!(\"Success: {}\", value))\n}\n```\n\n### Error Context with anyhow/eyre\n\n```rust\nuse color_eyre::Result;\nuse color_eyre::eyre::{eyre, WrapErr};\n\nfn load_config(path: &str) -> Result<Config> {\n    let content = std::fs::read_to_string(path)\n        .wrap_err_with(|| format!(\"Failed to read config file: {}\", path))?;\n    \n    let config: Config = toml::from_str(&content)\n        .wrap_err(\"Failed to parse config file\")?;\n    \n    if config.version < MIN_VERSION {\n        return Err(eyre!(\"Config version {} is too old\", config.version));\n    }\n    \n    Ok(config)\n}\n```\n\n### Custom Error Types\n\n```rust\n// Define domain-specific errors\n#[derive(Debug, thiserror::Error)]\npub enum ValidationError {\n    #[error(\"Value {0} is out of range [{1}, {2}]\")]\n    OutOfRange(i32, i32, i32),\n    \n    #[error(\"Invalid format: expected {expected}, got {actual}\")]\n    InvalidFormat { expected: String, actual: String },\n}\n\n// Implement conversions\nimpl From<ValidationError> for AppError {\n    fn from(err: ValidationError) -> Self {\n        AppError::Validation(err)\n    }\n}\n```\n\n## Memory Management\n\n### Ownership Rules\n\n```rust\n// 1. Each value has a single owner\nlet s1 = String::from(\"hello\");\nlet s2 = s1;  // s1 is moved, no longer valid\n// println!(\"{}\", s1);  // ERROR: use of moved value\n\n// 2. References must not outlive their data\nfn invalid_reference() -> &String {  // ERROR: missing lifetime\n    let s = String::from(\"hello\");\n    &s  // s is dropped here\n}\n\n// 3. Cannot have mutable and immutable references simultaneously\nlet mut s = String::from(\"hello\");\nlet r1 = &s;  // Immutable borrow\nlet r2 = &s;  // Another immutable borrow - OK\n// let r3 = &mut s;  // ERROR: cannot borrow as mutable\n```\n\n### Smart Pointers\n\n```rust\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::sync::Arc;\nuse std::sync::Mutex;\n\n// Single-threaded reference counting\nlet rc = Rc::new(vec![1, 2, 3]);\nlet rc_clone = Rc::clone(&rc);\n\n// Interior mutability for single-threaded code\nlet cell = RefCell::new(5);\n*cell.borrow_mut() += 1;\n\n// Thread-safe reference counting\nlet arc = Arc::new(Mutex::new(0));\nlet arc_clone = Arc::clone(&arc);\n\n// Spawn thread with shared data\nstd::thread::spawn(move || {\n    let mut data = arc_clone.lock().unwrap();\n    *data += 1;\n});\n```\n\n### Avoiding Memory Leaks\n\n```rust\n// Use weak references to break cycles\nuse std::rc::{Rc, Weak};\n\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\n// RAII pattern - automatic cleanup\nstruct TempFile {\n    path: PathBuf,\n}\n\nimpl Drop for TempFile {\n    fn drop(&mut self) {\n        let _ = std::fs::remove_file(&self.path);\n    }\n}\n```\n\n## Async Programming\n\n### Tokio Best Practices\n\n```rust\nuse tokio::time::{sleep, Duration};\nuse tokio::sync::mpsc;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // Spawn concurrent tasks\n    let handle1 = tokio::spawn(async {\n        sleep(Duration::from_secs(1)).await;\n        \"Task 1 complete\"\n    });\n    \n    let handle2 = tokio::spawn(async {\n        sleep(Duration::from_secs(2)).await;\n        \"Task 2 complete\"\n    });\n    \n    // Wait for both tasks\n    let (result1, result2) = tokio::join!(handle1, handle2);\n    println!(\"{}, {}\", result1?, result2?);\n    \n    Ok(())\n}\n\n// Channels for communication\nasync fn channel_example() {\n    let (tx, mut rx) = mpsc::channel(100);\n    \n    tokio::spawn(async move {\n        for i in 0..10 {\n            tx.send(i).await.unwrap();\n        }\n    });\n    \n    while let Some(value) = rx.recv().await {\n        println!(\"Received: {}\", value);\n    }\n}\n```\n\n### Async Error Handling\n\n```rust\nuse tokio::time::timeout;\n\nasync fn with_timeout() -> Result<String> {\n    match timeout(Duration::from_secs(5), slow_operation()).await {\n        Ok(result) => result,\n        Err(_) => Err(eyre!(\"Operation timed out\")),\n    }\n}\n\n// Retry logic\nasync fn with_retry<F, T>(mut f: F) -> Result<T>\nwhere\n    F: FnMut() -> futures::future::BoxFuture<'static, Result<T>>,\n{\n    let mut retries = 3;\n    loop {\n        match f().await {\n            Ok(value) => return Ok(value),\n            Err(e) if retries > 0 => {\n                retries -= 1;\n                sleep(Duration::from_secs(1)).await;\n                continue;\n            }\n            Err(e) => return Err(e),\n        }\n    }\n}\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use pretty_assertions::assert_eq;\n\n    #[test]\n    fn test_basic_functionality() {\n        let result = calculate(2, 3);\n        assert_eq!(result, 5);\n    }\n\n    #[test]\n    #[should_panic(expected = \"divide by zero\")]\n    fn test_panic() {\n        divide(10, 0);\n    }\n\n    #[test]\n    fn test_result() -> Result<()> {\n        let value = risky_operation()?;\n        assert!(value > 0);\n        Ok(())\n    }\n}\n```\n\n### Integration Tests\n\n```rust\n// tests/integration_test.rs\nuse my_crate::Client;\n\n#[tokio::test]\nasync fn test_client_connection() {\n    let client = Client::new(\"localhost:8080\");\n    let response = client.get(\"/health\").await.unwrap();\n    assert_eq!(response.status(), 200);\n}\n\n// Test with fixtures\n#[test]\nfn test_with_temp_dir() {\n    let temp_dir = tempfile::tempdir().unwrap();\n    let file_path = temp_dir.path().join(\"test.txt\");\n    \n    std::fs::write(&file_path, \"test content\").unwrap();\n    \n    // Test code that uses the file\n    let content = std::fs::read_to_string(&file_path).unwrap();\n    assert_eq!(content, \"test content\");\n    \n    // temp_dir is automatically cleaned up\n}\n```\n\n### Property-Based Testing\n\n```rust\nuse proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn test_parse_and_format(s in \"[0-9]{1,10}\") {\n        let n: u64 = s.parse().unwrap();\n        let formatted = format!(\"{}\", n);\n        prop_assert_eq!(s, formatted);\n    }\n}\n```\n\n## Performance Guidelines\n\n### Benchmarking\n\n```rust\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\n\nfn fibonacci(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        1 => 1,\n        n => fibonacci(n-1) + fibonacci(n-2),\n    }\n}\n\nfn criterion_benchmark(c: &mut Criterion) {\n    c.bench_function(\"fib 20\", |b| {\n        b.iter(|| fibonacci(black_box(20)))\n    });\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);\n```\n\n### Performance Tips\n\n```rust\n// 1. Use iterators instead of indexing\nlet sum: i32 = vec.iter().sum();  // Good\nlet mut sum = 0;\nfor i in 0..vec.len() {  // Less efficient\n    sum += vec[i];\n}\n\n// 2. Avoid unnecessary allocations\nfn process(data: &[u8]) -> Vec<u8> {\n    let mut result = Vec::with_capacity(data.len());  // Pre-allocate\n    for &byte in data {\n        if byte != 0 {\n            result.push(byte);\n        }\n    }\n    result\n}\n\n// 3. Use const generics for compile-time optimization\nfn dot_product<const N: usize>(a: &[f64; N], b: &[f64; N]) -> f64 {\n    a.iter().zip(b.iter()).map(|(x, y)| x * y).sum()\n}\n\n// 4. Enable link-time optimization\n// In Cargo.toml:\n// [profile.release]\n// lto = true\n```\n\n## Security Considerations\n\n### Input Validation\n\n```rust\nuse validator::Validate;\n\n#[derive(Debug, Validate)]\nstruct UserInput {\n    #[validate(length(min = 1, max = 100))]\n    username: String,\n    \n    #[validate(email)]\n    email: String,\n    \n    #[validate(range(min = 18, max = 150))]\n    age: u8,\n}\n\nfn process_input(input: UserInput) -> Result<()> {\n    input.validate()?;\n    // Process validated input\n    Ok(())\n}\n```\n\n### Secure Random\n\n```rust\nuse rand::Rng;\nuse rand::distributions::Alphanumeric;\n\nfn generate_token() -> String {\n    rand::thread_rng()\n        .sample_iter(&Alphanumeric)\n        .take(32)\n        .map(char::from)\n        .collect()\n}\n```\n\n### Avoiding Common Vulnerabilities\n\n```rust\n// SQL injection prevention\nuse sqlx::query;\n\nasync fn get_user(id: i32) -> Result<User> {\n    // Use parameterized queries\n    let user = query_as!(User, \"SELECT * FROM users WHERE id = $1\", id)\n        .fetch_one(&pool)\n        .await?;\n    Ok(user)\n}\n\n// Path traversal prevention\nuse std::path::{Path, PathBuf};\n\nfn safe_path_join(base: &Path, user_input: &str) -> Result<PathBuf> {\n    let path = base.join(user_input);\n    \n    // Ensure the path is within the base directory\n    if !path.starts_with(base) {\n        return Err(eyre!(\"Path traversal attempt detected\"));\n    }\n    \n    Ok(path)\n}\n```\n\n## Common Patterns\n\n### Builder Pattern\n\n```rust\n#[derive(Default)]\nstruct ServerBuilder {\n    host: Option<String>,\n    port: Option<u16>,\n    threads: Option<usize>,\n}\n\nimpl ServerBuilder {\n    fn new() -> Self {\n        Self::default()\n    }\n    \n    fn host(mut self, host: impl Into<String>) -> Self {\n        self.host = Some(host.into());\n        self\n    }\n    \n    fn port(mut self, port: u16) -> Self {\n        self.port = Some(port);\n        self\n    }\n    \n    fn threads(mut self, threads: usize) -> Self {\n        self.threads = Some(threads);\n        self\n    }\n    \n    fn build(self) -> Result<Server> {\n        Ok(Server {\n            host: self.host.unwrap_or_else(|| \"localhost\".to_string()),\n            port: self.port.unwrap_or(8080),\n            threads: self.threads.unwrap_or(4),\n        })\n    }\n}\n\n// Usage\nlet server = ServerBuilder::new()\n    .host(\"0.0.0.0\")\n    .port(3000)\n    .threads(8)\n    .build()?;\n```\n\n### Type State Pattern\n\n```rust\nstruct Connection<State> {\n    _state: PhantomData<State>,\n}\n\nstruct Disconnected;\nstruct Connected;\n\nimpl Connection<Disconnected> {\n    fn connect(self) -> Result<Connection<Connected>> {\n        // Connection logic\n        Ok(Connection { _state: PhantomData })\n    }\n}\n\nimpl Connection<Connected> {\n    fn send(&self, data: &[u8]) -> Result<()> {\n        // Can only send when connected\n        Ok(())\n    }\n    \n    fn disconnect(self) -> Connection<Disconnected> {\n        Connection { _state: PhantomData }\n    }\n}\n```\n\n### Newtype Pattern\n\n```rust\n#[derive(Debug, Clone, PartialEq, Eq)]\nstruct UserId(u64);\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nstruct PostId(u64);\n\nimpl UserId {\n    fn new(id: u64) -> Self {\n        Self(id)\n    }\n}\n\n// Prevents mixing up user IDs and post IDs\nfn get_posts_by_user(user_id: UserId) -> Vec<Post> {\n    // Implementation\n}\n```\n\n## Development Workflow\n\n### Code Organization\n\n```\nmy_project/\n├── Cargo.toml\n├── src/\n│   ├── main.rs          # Binary entry point\n│   ├── lib.rs           # Library root\n│   ├── config.rs        # Configuration\n│   ├── errors.rs        # Error types\n│   ├── models/          # Data structures\n│   │   ├── mod.rs\n│   │   ├── user.rs\n│   │   └── post.rs\n│   ├── handlers/        # Business logic\n│   │   ├── mod.rs\n│   │   └── api.rs\n│   └── utils/           # Utilities\n│       ├── mod.rs\n│       └── validation.rs\n├── tests/\n│   └── integration_test.rs\n├── benches/\n│   └── benchmark.rs\n└── examples/\n    └── example.rs\n```\n\n### CI/CD Configuration\n\n```yaml\n# .github/workflows/rust.yml\nname: Rust\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: dtolnay/rust-toolchain@stable\n      with:\n        components: rustfmt, clippy\n    \n    - name: Check formatting\n      run: cargo fmt -- --check\n    \n    - name: Clippy\n      run: cargo clippy -- -D warnings\n    \n    - name: Test\n      run: cargo test\n    \n    - name: Audit\n      run: cargo audit\n```\n\n### Pre-commit Hooks\n\n```bash\n#!/bin/bash\n# .git/hooks/pre-commit\n\n# Format code\ncargo fmt\n\n# Run clippy\ncargo clippy -- -D warnings || exit 1\n\n# Run tests\ncargo test || exit 1\n\n# Check for TODOs\nif grep -r \"TODO\\|FIXME\\|XXX\" src/; then\n    echo \"Found TODOs in code\"\n    exit 1\nfi\n```\n\n## Debugging Tips\n\n### Using dbg! Macro\n\n```rust\nlet x = 5;\nlet y = dbg!(x * 2) + 1;  // Prints: [src/main.rs:2] x * 2 = 10\ndbg!(&y);  // Prints: [src/main.rs:3] &y = 11\n```\n\n### Logging with tracing\n\n```rust\nuse tracing::{debug, info, warn, error, instrument};\n\n#[instrument]\nfn process_request(id: u64) -> Result<Response> {\n    debug!(\"Processing request\");\n    \n    let data = fetch_data(id)?;\n    info!(%id, data_len = data.len(), \"Data fetched successfully\");\n    \n    if data.is_empty() {\n        warn!(\"Empty data returned\");\n    }\n    \n    Ok(Response::new(data))\n}\n\n// Initialize tracing\nfn main() {\n    tracing_subscriber::fmt()\n        .with_max_level(tracing::Level::DEBUG)\n        .init();\n    \n    // Your application code\n}\n```\n\n### Using rust-gdb/rust-lldb\n\n```bash\n# Compile with debug symbols\ncargo build\n\n# Debug with gdb\nrust-gdb target/debug/my_program\n\n# Or with lldb\nrust-lldb target/debug/my_program\n\n# Common gdb commands:\n# break main              # Set breakpoint at main\n# run                     # Run the program\n# next                    # Step over\n# step                    # Step into\n# print variable_name     # Print variable value\n# backtrace              # Show stack trace\n```\n\nRemember: \n- Always handle errors explicitly\n- Use `cargo clippy` and `cargo fmt` regularly\n- Write tests for all public APIs\n- Document your code with examples\n- Keep dependencies minimal and up to date\n- Profile before optimizing\n- Prefer safe code, use `unsafe` only when necessary with proper documentation",
  "metadata": {
    "created_at": "2024-01-01T00:00:00Z",
    "updated_at": "2024-01-01T00:00:00Z",
    "tags": ["rust", "cargo", "development", "best-practices", "safety", "performance"],
    "is_builtin": false,
    "author": "Gemini CLI Manager Team"
  }
}